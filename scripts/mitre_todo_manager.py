#!/usr/bin/env python3
"""
Enhanced Knowledge Base Processor with MITRE TODO Integration

This script integrates with the MITRE sync data to automatically process
techniques from our comprehensive todo list.
"""

import json
import argparse
import sys
from pathlib import Path
import os

def load_mitre_todo_list(todo_file="mitre_data/mitre_todo_list.json"):
    """Load the MITRE todo list generated by mitre_sync.py"""
    if not os.path.exists(todo_file):
        print(f"[-] MITRE todo list not found: {todo_file}")
        print("[!] Run 'python3 scripts/mitre_sync.py' first to generate the todo list")
        return None
    
    try:
        with open(todo_file, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"[-] Failed to load todo list: {e}")
        return None

def get_priority_techniques(todo_data, priority_type="high_priority", platform=None, limit=10):
    """Get priority techniques from the todo list"""
    if not todo_data:
        return []
    
    techniques = []
    
    if priority_type == "high_priority":
        techniques = todo_data["priority_lists"]["high_priority"]
    elif priority_type == "commonly_used":
        techniques = todo_data["priority_lists"]["commonly_used"]
    elif priority_type == "new_techniques":
        techniques = todo_data["priority_lists"]["new_techniques"]
    elif priority_type == "subtechniques":
        techniques = todo_data["priority_lists"]["subtechniques"]
    elif priority_type == "platform_specific":
        if platform and platform in todo_data["platforms"]:
            techniques = [
                {
                    "id": item["id"],
                    "name": item["name"],
                    "platforms": [platform],
                    "is_subtechnique": item["is_subtechnique"]
                }
                for item in todo_data["platforms"][platform]["todo"]
            ]
    
    # Filter by platform if specified
    if platform and priority_type != "platform_specific":
        techniques = [t for t in techniques if platform in t.get("platforms", [])]
    
    return techniques[:limit]

def suggest_next_batch(todo_data, batch_size=5, focus_platform=None):
    """Suggest the next batch of techniques to work on"""
    if not todo_data:
        return []
    
    suggestions = {
        "high_priority": [],
        "platform_coverage": [],
        "commonly_used": [],
        "quick_wins": []
    }
    
    # High priority execution techniques
    high_priority = get_priority_techniques(todo_data, "high_priority", focus_platform, batch_size)
    suggestions["high_priority"] = high_priority
    
    # Platform-specific for better coverage
    if focus_platform:
        platform_specific = get_priority_techniques(todo_data, "platform_specific", focus_platform, batch_size)
        suggestions["platform_coverage"] = platform_specific
    
    # Commonly used techniques
    commonly_used = get_priority_techniques(todo_data, "commonly_used", focus_platform, batch_size)
    suggestions["commonly_used"] = commonly_used
    
    # Quick wins (main techniques, not sub-techniques)
    all_todo = todo_data.get("todo", [])
    quick_wins = [t for t in all_todo if not t.get("is_subtechnique", False)]
    if focus_platform:
        quick_wins = [t for t in quick_wins if focus_platform in t.get("platforms", [])]
    suggestions["quick_wins"] = quick_wins[:batch_size]
    
    return suggestions

def create_technique_template(technique_data, base_path="."):
    """Create a new technique folder structure based on MITRE data"""
    technique_id = technique_data["id"]
    platforms = technique_data.get("platforms", ["unknown"])
    
    created_folders = []
    
    for platform in platforms:
        # Skip cloud/abstract platforms for now
        if platform.lower() not in ["windows", "linux", "macos"]:
            continue
            
        folder_path = Path(base_path) / platform.lower() / "internals" / "techniques" / technique_id
        folder_path.mkdir(parents=True, exist_ok=True)
        
        # Create empty template files
        template_files = [
            "description.md",
            "detection.md", 
            "mitigation.md",
            "purple_playbook.md",
            "references.md",
            "agent_notes.md"
        ]
        
        for file_name in template_files:
            file_path = folder_path / file_name
            if not file_path.exists():
                # Create minimal template content
                content = create_template_content(file_name, technique_data)
                file_path.write_text(content)
        
        # Create code_samples directory
        code_samples_dir = folder_path / "code_samples"
        code_samples_dir.mkdir(exist_ok=True)
        
        created_folders.append(str(folder_path))
    
    return created_folders

def create_template_content(file_name, technique_data):
    """Create minimal template content for each file type"""
    technique_id = technique_data["id"]
    technique_name = technique_data.get("name", "Unknown Technique")
    
    templates = {
        "description.md": f"""# Technique {technique_id}: {technique_name}

## Overview
- Category: [To be determined]
- Platform: {', '.join(technique_data.get('platforms', ['Unknown']))}
- MITRE ID: {technique_id}

## Technical Details
[Detailed explanation of how {technique_name} works]

## Adversary Use Cases
[How attackers use {technique_name} in real-world scenarios]

## Platform-Specific Implementation
[Platform-specific details and variations]

## Detection Considerations
[Key indicators and behaviors to monitor]
""",
        
        "detection.md": f"""# Detection: {technique_id} - {technique_name}

## Detection Strategy
[Overall approach to detecting {technique_name}]

## Sigma Rules
```yaml
# Add Sigma detection rules here
```

## KQL Queries
```kusto
// Add KQL queries here
```

## Splunk SPL
```spl
// Add Splunk queries here
```

## Detection Notes
[Additional detection guidance]
""",
        
        "mitigation.md": f"""# Mitigation: {technique_id} - {technique_name}

## Prevention
[Preventive controls for {technique_name}]

## Detection
[Detective controls and monitoring]

## Response
[Incident response procedures]

## Implementation Notes
[Specific implementation guidance]
""",
        
        "purple_playbook.md": f"""# Purple Team Playbook: {technique_id} - {technique_name}

## Objective
Test detection and response capabilities for {technique_name}.

## Red Team Simulation
[Attack simulation steps]

## Blue Team Validation
[Detection validation steps]

## Success Criteria
[Measurable objectives]
""",
        
        "references.md": f"""# References: {technique_id} - {technique_name}

## MITRE ATT&CK
- [MITRE ATT&CK - {technique_id}]({technique_data.get('url', f'https://attack.mitre.org/techniques/{technique_id}/')})

## Research Papers
[Add research references]

## Tools & Resources
[Add relevant tools and resources]
""",
        
        "agent_notes.md": f"""# Agent Notes: {technique_id} - {technique_name}

## Research Priority
[Priority level and reasoning]

## Key Research Areas
[Areas needing investigation]

## Automation Opportunities
[Potential for automated content generation]
"""
    }
    
    return templates.get(file_name, f"# {file_name}\n\nContent for {technique_id}: {technique_name}")

def update_project_status(new_techniques, status_file="project_status.json"):
    """Update project status with new techniques"""
    # Load existing status
    status = {"techniques": []}
    if os.path.exists(status_file):
        try:
            with open(status_file, 'r') as f:
                status = json.load(f)
        except Exception as e:
            print(f"[-] Warning: Could not load existing status: {e}")
    
    # Add new techniques
    existing_ids = {t["id"] for t in status["techniques"]}
    
    for technique_data in new_techniques:
        technique_id = technique_data["id"]
        platforms = technique_data.get("platforms", ["unknown"])
        
        for platform in platforms:
            if platform.lower() not in ["windows", "linux", "macos"]:
                continue
                
            if technique_id not in existing_ids:
                status["techniques"].append({
                    "id": technique_id,
                    "platform": platform.title(),
                    "status": "template_created",
                    "files": ["description.md", "code_samples/", "detection.md", "mitigation.md", "purple_playbook.md", "references.md", "agent_notes.md"]
                })
    
    # Save updated status
    with open(status_file, 'w') as f:
        json.dump(status, f, indent=2)
    
    print(f"[+] Updated project status: {status_file}")

def main():
    parser = argparse.ArgumentParser(description="MITRE TODO List Management")
    parser.add_argument("--action", choices=["list", "suggest", "create", "stats"], 
                       default="suggest", help="Action to perform")
    parser.add_argument("--platform", choices=["windows", "linux", "macos"],
                       help="Focus on specific platform")
    parser.add_argument("--priority", choices=["high_priority", "commonly_used", "new_techniques", "subtechniques"],
                       default="high_priority", help="Priority category")
    parser.add_argument("--batch-size", type=int, default=5,
                       help="Number of techniques to process")
    parser.add_argument("--create-templates", action="store_true",
                       help="Create folder templates for suggested techniques")
    parser.add_argument("--todo-file", default="mitre_data/mitre_todo_list.json",
                       help="Path to MITRE todo list file")
    
    args = parser.parse_args()
    
    # Load todo list
    todo_data = load_mitre_todo_list(args.todo_file)
    if not todo_data:
        sys.exit(1)
    
    if args.action == "stats":
        # Show statistics
        metadata = todo_data["metadata"]
        print(f"MITRE ATT&CK Coverage Statistics")
        print(f"{'='*40}")
        print(f"Total techniques: {metadata['total_techniques']}")
        print(f"Completed: {metadata['completed_techniques']}")
        print(f"Remaining: {metadata['remaining_techniques']}")
        print(f"Coverage: {metadata['coverage_percentage']}%")
        print()
        
        print("Platform Breakdown:")
        for platform, data in todo_data["platforms"].items():
            coverage = round((data["completed"] / data["total"]) * 100, 2) if data["total"] > 0 else 0
            print(f"  {platform}: {data['completed']}/{data['total']} ({coverage}%)")
    
    elif args.action == "list":
        # List techniques by priority
        techniques = get_priority_techniques(todo_data, args.priority, args.platform, args.batch_size * 2)
        print(f"Top {len(techniques)} {args.priority.replace('_', ' ')} techniques:")
        print(f"{'='*50}")
        
        for i, technique in enumerate(techniques, 1):
            status = "ðŸ“‹ Sub-technique" if technique.get("is_subtechnique") else "ðŸŽ¯ Technique"
            platforms = ", ".join(technique.get("platforms", ["unknown"]))
            print(f"{i:2d}. {status} **{technique['id']}**: {technique['name']}")
            print(f"     Platforms: {platforms}")
    
    elif args.action == "suggest":
        # Suggest next batch
        suggestions = suggest_next_batch(todo_data, args.batch_size, args.platform)
        
        print(f"Suggested next techniques to work on:")
        print(f"{'='*50}")
        
        for category, techniques in suggestions.items():
            if techniques:
                print(f"\nðŸŽ¯ {category.replace('_', ' ').title()} ({len(techniques)} techniques):")
                for technique in techniques:
                    status = "ðŸ“‹" if technique.get("is_subtechnique") else "ðŸŽ¯"
                    platforms = ", ".join(technique.get("platforms", ["unknown"]))
                    print(f"  {status} {technique['id']}: {technique['name']} ({platforms})")
    
    elif args.action == "create":
        # Create templates for priority techniques
        techniques = get_priority_techniques(todo_data, args.priority, args.platform, args.batch_size)
        
        if not techniques:
            print("[-] No techniques found for the specified criteria")
            sys.exit(1)
        
        print(f"Creating templates for {len(techniques)} techniques...")
        created_folders = []
        
        for technique in techniques:
            folders = create_technique_template(technique)
            created_folders.extend(folders)
            print(f"[+] Created template for {technique['id']}: {technique['name']}")
        
        # Update project status
        update_project_status(techniques)
        
        print(f"\n[+] Created {len(created_folders)} technique folders")
        print("Next steps:")
        print("1. Run the Ollama automation script to generate content")
        print("2. Review and refine the generated documentation")
        print("3. Test detection rules and purple team playbooks")

if __name__ == "__main__":
    main()
